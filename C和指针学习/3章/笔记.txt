长整型(至少32位)至少应该和整型一样长，而整型至少和短整型(至少16位)一样长

char类型虽然目的是为了容纳字符型整型,但是字符本质上是小整型.缺省的char要么是signed char,要么是unsigned char,取决于编译器许多处理字符的库函数

许多处理字符的库函数把它们的参数声明为char,如果把参数显示声明为unsigned或者signed的话,可能会带来兼容性的问题.

字面值这个术语是字面值常量的缩写.这是一种实体,指定了自身的值,并且不允许发生改变.如ANSI C允许命名常量(const)

整数也可以用八进制和十六进制使用,只要加上0和0x即可.

在int的缺省情况下,字面值的类型就是上述类型中最短但是足以容纳整个值的类型

如果一个多字节字符常量的前面有一个L,那么他就是宽字符常量.如L'X'   L'e^'(字符常量的类型总是int)

枚举中默认的顺序是从0开始,可以自主赋值

标准规定所有的浮点类型至少能容纳从10^-37到10^37之间的值

浮点数字面值总是写成十进制的形式,他必须有一个小数点或者指数,也可以两者都有.

变量声明的基本形式: 说明符(一个或多个)  声明表达式

说明符即类似int, 多个的话类似 unsigned int 或者 long long int

signed一般只针对于char类型,因为别的缺省一般都是有符号数

编译器并不检查数组下标的引用是否在数组的合法范围之内.

char *p = "hello world!"这个初始化指针的表达式中,是直接给p本身赋值的.

应该用typedef而不是用define来创建新的变量名.因为后者无法正确的处理指针类型,如下:#define c char*  c a,b;这里会发现只有a是指针而b只是一个整型

int const a;这条语句把a声明为一个整数,它的值不能被改变.涉及到指针的const更为有趣:
int const *p1;是一个指向整型常量的指针.你可以修改指针的值,但是你不能改变它所指向的值.
int * const pi;是一个指向整型的常量指针,此时指针是常量,它的值无法改变,但是你可以修改它所指向的整型的值.
int  const * const pi;无论指针本身还是所指向的值都是常量,都不能改变.

名字常量非常有用,因为他们可以给数值起符号名,否则他们就只能写成字面值的形式.这样修改和搜索起来都更加方便.

如果函数中声明了一个局部变量,其中变量名与形参传入的变量名相同,则函数体只能访问这个局部变量.形参将不能访问.

链接属性一共有三种:external(外部),internal(内部)和none(无).没有链接属性的标识符总是被当做单独的个体,也就是说该标识符的多个声明被当做独立不同的实体.属于internal的链接属性的标识符在同一个源文件内的所有声明中都指向同一个实体,但位于不同的源文件的多个声明则分属不同的实体.最后属于external链接属性的标识符不论声明多少次,位于几个源文件都表示同一个实体.

关键字extern和static用于在声明中修改标识符的链接属性.如果某个声明在正常情况下具有external链接属性,在它前面加static关键字可以将其链接属性改成internal,static只对缺省为extern的声明才有改变其链接属性的特点.

有三个地方可以用于存储变量:普通内存,运行时堆栈,硬件寄存器.这三个地方存储的变量具有不同的特性.

凡是在任何代码块之外声明的变量都是存储于静态内存中,而不属于堆栈的内存,称为静态变量,在程序执行之前即创建.
在代码块内部声明的变量的缺省值是自动的,也就是说它存储于堆栈中.
关键字register可以用于自动变量的声明,题是他们应该存储于机器的硬件寄存器而不是内存中,这类变量称为寄存器变量.如果有太多register,它只选取前几个实际存储于寄存器.寄存器变量比存储于内存的变量访问效率更高.



