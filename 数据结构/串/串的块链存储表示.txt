和线性表的链式存储结构相似，也可利用链表方式存储串值。由于串结构的特殊性--结构中的每个数据与元素是一个字符，则利用链表存储串值时，存在一个“结点大小”的问题，每个结点可以存放一个字符，也可以存放多个字符。当结点大于1时，由于串长不一定是结点大小的整倍数，则链表最后一个结点不一定全部被串值占满。此时通常补上'#'或其他的非串值字符(通常'#'不属于串的字符集，是一个特殊的符号)

为了便于进行串的操作，当以链表存储串值时，除头指针外，还可附设一个尾指针指示链表中最后一个结点，并给出当前串的长度。称如此定义的串存储结构为块链结构，

//= = = = = =  串的块链存储表示 = = = = = = = 
#define CHUNKSIZE 80
typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;
typedef struct{
	Chunk *head, *tail;     //串的头指针和尾指针
	in curlen;              //串的当前长度
}LString;


存储密度的定义：

存储密度 = 串值所占的存储位/实际分配的存储位

如果再串处理过程中需要进行内外存交换的话，则会因为内存交换操作过多而影响处理的总效率。应该看到，串的字符集的大小也是一个重要的因素。一般地，字符集小，则字符的机内编码就短，这也影响串值的存储方式的选取。
