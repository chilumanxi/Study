模拟一个影院的售票系统,写如下一个程序:

while(1){
    if(num == 0){
        printf("no ticket!\n");
        exit(0);
    }
    else{
        num -= 1;
    }
}

但是这是存在着很严重的问题的,因为多线程是并发的,所以假设在子线程A和B在执行if判断时都通过了,但此时又只存在一张票.那么问题就是两个进程都会将票数减1,导致出售过多的票.

所以涉及到多线程同步的问题:

互斥锁是一个特殊的有锁上和非锁上两种状态.一般被设置为全局变量.非上锁的互斥锁会被线程得到,一旦获得,这个互斥锁就会锁上,此后只有该线程有权打开

条件变量特别适用于多个线程等待某个条件的发生.如果不适用条件变量,那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生.
