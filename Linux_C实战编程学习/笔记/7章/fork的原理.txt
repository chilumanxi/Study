Linux通过clone()系统调用实现fork()，然后由clone调用do_fork()

do_fork完成了创建中的大部分工作。该函数调用copy_process函数，然后让进程开始运行下面解释一下copy_process的作用

（1）调用函数为新进程创建一个内核栈，此时子进程和父进程描述符是完全相同的。

（2）检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。

（3）子进程着手使自己与父进程区分开来，进程描述符内的许多称愿都要被清0或者被设为初始值，那些不是继承而来的进程描述符称愿主要是统计信息，仍未被更改。

（4）紫禁城的状态被设置为保证它不会进行的状态。

（5）copy_process调用copy_flags以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERRPIV标志被清为0，表明进程还没有调用exec函数的PF_FORKNOEXEC标志被设置。

（6）调用alloc_pid为新进程分配一个有效的PID

（7）根据传递给clone的参数标志，copy_process拷贝或共享打开文件，文件系统信息，信号处理函数，进程地址空间和命名空间等。一般情况下，这写资源会被给定进程的所有线程共享，否则，这些资源队每个进程都是不同的，因此被拷贝到这里。

（8）最后的扫尾工作后，返回一个指向子进程的指针，返回do_fork函数，新进程被唤醒并被投入运行
